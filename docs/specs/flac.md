# 音声エンジニアリング仕様書: FLAC/WAV 処理パイプライン

本ドキュメントは、VLogシステムにおける音声のキャプチャ、永続化、および構造化データの抽出に関する技術仕様を、ソースコード・レベルの精度で網羅的に定義します。

## 1. 音声キャプチャ・詳細仕様 (`infrastructure/audio.rs`)

システムは `cpal` および `hound` クレートを組み合わせた、低レイテンシかつ堅牢な録音パイプラインを構築しています。

### 1.1 ハードウェア・パラメータ
- **サンプリングレート**: `16,000 Hz` (固定)
- **チャンネル数**: `1` (モノラル固定)
- **ビット深度**: `16-bit` (Signed Integer / i16)
- **オーディオドライバ**: OS標準のデフォルト・インプットデバイスを使用。
    - **デバイス選択ロジック**: `Settings` でデバイス名が指定されている場合、`cpal::Host` から `name().contains(&name)` で部分一致検索を実行。見つからない場合は `default_input_device()` へフォールバックします。

### 1.2 低レベル・ゲート制御と可視化
計算コストを抑えた振幅評価フィルターおよび診断機能を `build_input_stream` のコールバック内に実装：
- **無音抑制 (Silence Gate)**: 条件 `abs_sample >= silence_threshold`。
    - `0.0` 指定時は全サンプルを透過し、環境の「物理的現実」を100%キャプチャします。
- **ピーク振幅診断**: 10秒周期で実行。
    - コールバック内で区間内の最大振幅 `local_peak` を計算し、10秒ごとに `info!("Recording status: peak_amplitude={:.4}", *p)` としてログ出力。これにより、マイク入力が小さすぎないか、あるいは仮想デバイスが正しく選択されているかを外部から診断可能にします。
- **クリッピング防止**: `sample.clamp(-1.0, 1.0)` により、i16 範囲外へのオーバーフローを防ぎます。

### 1.3 スレッド・安全性とライフサイクル
- **オーケストレーション**: `tokio::spawn` ではなく、録音専用の `std::thread::spawn` で実行（OSスレッド）。
- **ステート管理**: `Arc<AtomicBool>` によるスレッド間フラグ共有により、メインループからの停止命令を 100ms 精度で受信。
- **アトミック・ファイナライズ**: 停止時、`.wav.part`（一時ファイル）を `finalize()` した後、アトミックに `.wav` へリネーム。これにより、書き込み途中の破損ファイルが後続の処理に回るのを防ぎます。

---

## 2. 音声正規化・アーカイブ・パイプライン

システムは、録音された WAV を直接 Whisper/Gemini に送るのではなく、FFmpeg を介した正規化工法を適用します。

### 2.1 転送用正規化 (Normalization for AI)
- **コマンド**: `ffmpeg -y -i {input} -ar 16000 -ac 1 {output_wav}`
- **目的**: 
    - 入力デバイスの設定（ステレオ/モノラル、サンプレート）に関わらず、Gemini / Whisper が最も効率的に処理できる `16kHz / Mono` 形式へ強制変換。
    - `/tmp` 領域などの一時ファイルとして生成し、API 送信後に自動破棄。

### 2.2 長期アーカイブ仕様 (Towards FLAC/Opus)
将来的なストレージ消費の最適化として、以下の archival パイプラインを定義します：
- **FLAC エンコード**: `ffmpeg -i {input.wav} -af aformat=s16:16000 -sample_fmt s16 {output.flac}`
    - 非可逆圧縮を避け、物理的現実の「原音」を lossless で保持。
- **Opus エンコード (超軽量モード)**: `ffmpeg -i {input.wav} -c:a libopus -b:a 12k {output.opus}`
    - ナラティブ記録として十分な音質（12kbps）を維持しつつ、WAV 比で約 90% 以上の容量削減を実現。
- **実装状況**: `use_cases/transcode.rs` にて `libopus` への変換・元ファイル削除ロジックが統合済み。

---

## 3. 構造化前処理エンジン (`infrastructure/preprocessor.rs`)

生テキスト（Raw Transcription）を「ナラティブ資源」へと高品質化するための多段階フィルタリング・ロジックです。

### 3.1 テキスト正規化
1. **三点リーダー置換**: 全角「…」を半角スペースに一律置換。
2. **記号集約**: 正規表現 `r"\.{2,}"` を用いて、2つ以上連続するドットを1つの半角スペースに集約。

### 2.2 特殊アルゴリズム：反復・スタッター除去
単純な正規表現では捉えにくい「吃音」や「機械的ループ」を以下のアルゴリズムで解消します。
- **探索範囲**: 各文字位置から、長さ `1` から `4` 文字のパターンを探索。
- **条件**: そのパターンが **5回以上連続** している場合に、1回分のみを残して後続を削除。
    - *例*: 「だだだだだ」 (len:1, count:5) → 「だ」
    - *例*: 「天気が天気が天気が天気が天気が」 (len:3, count:5) → 「天気が」

### 2.3 20回反復フィラー除去プログラム
フィラーは「入れ子構造」や「連続」して現れることが多いため、システムは以下のループ処理を実行します。
- **実行回数**: 最大 **20回** の再帰的置換ループ。
- **正規表現パターン**: `r"(^|[\s、。?!])({})(?=[\s、。?!]||$)"`
- **対象**: 下記37項目のリストを**文字列長が長い順**にソートして一括マッチング。
- **全項目リスト**: `えー`, `あのー`, `うーん`, `えっと`, `なんて`, `まあ`, `そうですね`, `あー`, `んー`, `うん`, `ふん`, `あ`, `はは`, `ははは`, `なんか`, `え`, `お`, `ふんふん`, `ふんふんふん`, `うんうん`, `うんうんうん`, `はいはい`, `はいはいはい`, `はいはいはいはい`, `おー`, `ああ`, `んふん`, `そっか`, `そっかぁ`, `そうか`, `そうなんだ`, `えへへ`, `あの`, `あのね`, `あのさ`, `ん`, `えっと`
- **判定**: ループ内で「前回の文字列と比較して変化がなくなった」時点で処理を打ち切る（収束判定）。

---

## 3. タスク・ライフサイクルとデータ永続化

### 3.1 `data/tasks.json` のプロトコル
システムは JSON データベース（`TaskRepository`）を介して状態を共有します。
```json
{
  "id": "YYYYMMDD_HHMMSS",
  "created_at": "RFC3339_DATETIME",
  "status": "pending | processing | completed | failed",
  "task_type": "process_session",
  "file_paths": ["data/recordings/filename.wav"]
}
```

### 3.2 出力物 (Output Artifacts)
1. **生録音**: `data/recordings/*.wav` (Linear PCM 16bit)
2. **構造化テキスト**: `data/transcripts/*.txt` (UTF-8, Preprocessed)
    - 保存先ディレクトリは `fs::create_dir_all` により実行時に自動担保。

---

## 4. 異常系への対応方針 (Crash-Only Policy)

1. **オーディオストリーム・エラー**:
    - 入力 callback 内でエラーを検知した場合、システムは `panic!` により即時終了します。
    - これは VLog プロジェクトの「中途半端な状態での継続を避け、外部の `systemd` 等によるクリーンな再起動を期待する」設計思想に基づいています。
2. **API タイムアウト**:
    - Gemini API へのアップロードが失敗した場合、タスクの `status` は `pending` に留まり、次回の `MonitorUseCase` ループ（30秒おき）で自動的に再試行されます。
