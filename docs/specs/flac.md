# 音声エンジニアリング仕様書: FLAC/WAV 処理パイプライン

本ドキュメントは、VLogシステムにおける音声のキャプチャ、永続化、および構造化データの抽出に関する技術仕様を、ソースコード・レベルの精度で網羅的に定義します。

## 1. 音声キャプチャ・詳細仕様 (`infrastructure/audio.rs`)

システムは `cpal` および `hound` クレートを組み合わせた、低レイテンシかつ堅牢な録音パイプラインを構築しています。

### 1.1 ハードウェア・パラメータ
- **サンプリングレート**: `16,000 Hz` (固定)
- **チャンネル数**: `1` (モノラル固定)
- **ビット深度**: `16-bit` (Signed Integer / i16)
- **オーディオドライバ**: OS標準のデフォルト・インプットデバイスを使用。
    - **デバイス選択ロジック**: `Settings` でデバイス名が指定されている場合、`cpal::Host` から `name().contains(&name)` で部分一致検索を実行。見つからない場合は `default_input_device()` へフォールバックします。

### 1.2 低レベル・ゲート制御
計算コストを抑えた振幅評価フィルターを `build_input_stream` のコールバック内に実装：
- **条件**: `sample.abs() > 0.005`
- **挙動**: デジタル振幅の 0.5% 未満の微細なノイズは、WAVライターに送られる前に破棄されます。これにより、完全な無音時（DCオフセットを除く）のデータ書き込みを抑制します。

### 1.3 スレッド・安全性とライフサイクル
- **オーケストレーション**: `tokio::spawn` ではなく、録音専用の `std::thread::spawn` で実行（OSスレッド）。
- **ステート管理**: `Arc<AtomicBool>` によるスレッド間フラグ共有により、メインループからの停止命令を 100ms 精度で受信。
- **ファイル終端処理**: 停止命令受信後、`hound::WavWriter` の `finalize()` を呼び出し、WAVヘッダ（ファイルサイズ等）を正しく書き換えます。

---

## 2. 構造化前処理エンジン (`infrastructure/preprocessor.rs`)

生テキスト（Raw Transcription）を「ナラティブ資源」へと高品質化するための多段階フィルタリング・ロジックです。

### 2.1 テキスト正規化
1. **三点リーダー置換**: 全角「…」を半角スペースに一律置換。
2. **記号集約**: 正規表現 `r"\.{2,}"` を用いて、2つ以上連続するドットを1つの半角スペースに集約。

### 2.2 特殊アルゴリズム：反復・スタッター除去
単純な正規表現では捉えにくい「吃音」や「機械的ループ」を以下のアルゴリズムで解消します。
- **探索範囲**: 各文字位置から、長さ `1` から `4` 文字のパターンを探索。
- **条件**: そのパターンが **5回以上連続** している場合に、1回分のみを残して後続を削除。
    - *例*: 「だだだだだ」 (len:1, count:5) → 「だ」
    - *例*: 「天気が天気が天気が天気が天気が」 (len:3, count:5) → 「天気が」

### 2.3 20回反復フィラー除去プログラム
フィラーは「入れ子構造」や「連続」して現れることが多いため、システムは以下のループ処理を実行します。
- **実行回数**: 最大 **20回** の再帰的置換ループ。
- **正規表現パターン**: `r"(^|[\s、。?!])({})(?=[\s、。?!]||$)"`
- **対象**: 下記37項目のリストを**文字列長が長い順**にソートして一括マッチング。
- **全項目リスト**: `えー`, `あのー`, `うーん`, `えっと`, `なんて`, `まあ`, `そうですね`, `あー`, `んー`, `うん`, `ふん`, `あ`, `はは`, `ははは`, `なんか`, `え`, `お`, `ふんふん`, `ふんふんふん`, `うんうん`, `うんうんうん`, `はいはい`, `はいはいはい`, `はいはいはいはい`, `おー`, `ああ`, `んふん`, `そっか`, `そっかぁ`, `そうか`, `そうなんだ`, `えへへ`, `あの`, `あのね`, `あのさ`, `ん`, `えっと`
- **判定**: ループ内で「前回の文字列と比較して変化がなくなった」時点で処理を打ち切る（収束判定）。

---

## 3. タスク・ライフサイクルとデータ永続化

### 3.1 `data/tasks.json` のプロトコル
システムは JSON データベース（`TaskRepository`）を介して状態を共有します。
```json
{
  "id": "YYYYMMDD_HHMMSS",
  "created_at": "RFC3339_DATETIME",
  "status": "pending | processing | completed | failed",
  "task_type": "process_session",
  "file_paths": ["data/recordings/filename.wav"]
}
```

### 3.2 出力物 (Output Artifacts)
1. **生録音**: `data/recordings/*.wav` (Linear PCM 16bit)
2. **構造化テキスト**: `data/transcripts/*.txt` (UTF-8, Preprocessed)
    - 保存先ディレクトリは `fs::create_dir_all` により実行時に自動担保。

---

## 4. 異常系への対応方針 (Crash-Only Policy)

1. **オーディオストリーム・エラー**:
    - 入力 callback 内でエラーを検知した場合、システムは `panic!` により即時終了します。
    - これは VLog プロジェクトの「中途半端な状態での継続を避け、外部の `systemd` 等によるクリーンな再起動を期待する」設計思想に基づいています。
2. **API タイムアウト**:
    - Gemini API へのアップロードが失敗した場合、タスクの `status` は `pending` に留まり、次回の `MonitorUseCase` ループ（30秒おき）で自動的に再試行されます。
